name: 'Fork Auto-Update'

on:
  schedule:
    - cron: '0 2 * * *' # Daily at 2 AM UTC
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update even if versions match'
        required: false
        type: 'boolean'
        default: false

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: 'Checkout'
        uses: 'actions/checkout@v4'
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 'Setup Node.js'
        uses: 'actions/setup-node@v4'
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: 'Configure Git'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: 'Add upstream remote'
        run: |
          git remote add upstream https://github.com/google-gemini/gemini-cli.git || true
          git fetch upstream --tags
      
      - name: 'Install dependencies'
        run: npm ci
      
      - name: 'Check for new version'
        id: check
        run: |
          VERSION_INFO=$(node scripts/check-upstream-version.js)
          echo "version_info=$VERSION_INFO"
          echo "$VERSION_INFO" | jq .
          
          LATEST=$(echo "$VERSION_INFO" | jq -r .latest)
          CURRENT=$(echo "$VERSION_INFO" | jq -r .current)
          UPDATE_NEEDED=$(echo "$VERSION_INFO" | jq -r .updateNeeded)
          UPSTREAM_TAG=$(echo "$VERSION_INFO" | jq -r .upstreamTag)
          
          echo "latest=$LATEST" >> $GITHUB_OUTPUT
          echo "current=$CURRENT" >> $GITHUB_OUTPUT
          echo "update_needed=$UPDATE_NEEDED" >> $GITHUB_OUTPUT
          echo "upstream_tag=$UPSTREAM_TAG" >> $GITHUB_OUTPUT
          
          if [ "${{ github.event.inputs.force_update }}" = "true" ]; then
            echo "update_needed=true" >> $GITHUB_OUTPUT
          fi
      
      - name: 'Find base commit'
        if: steps.check.outputs.update_needed == 'true'
        id: base
        run: |
          # Find the last upstream tag that was used as base
          BASE_TAG=$(git describe --tags --abbrev=0 --match="v*.*.*" --exclude="*-nightly*" --exclude="*-preview*" 2>/dev/null || echo "v0.6.1")
          echo "base_tag=$BASE_TAG" >> $GITHUB_OUTPUT
          echo "Base tag: $BASE_TAG"
      
      - name: 'Attempt rebase'
        if: steps.check.outputs.update_needed == 'true'
        id: rebase
        run: |
          set +e

          LATEST_VERSION="${{ steps.check.outputs.latest }}"
          UPSTREAM_TAG="${{ steps.check.outputs.upstream_tag }}"
          BASE_TAG="${{ steps.base.outputs.base_tag }}"
          BRANCH_NAME="update-to-${LATEST_VERSION}"

          echo "Rebasing from $BASE_TAG to $UPSTREAM_TAG"

          {
            echo "success=false"
            echo "conflicts=false"
            echo "needs_pr=false"
            echo "needs_issue=false"
            echo "branch_name="
            echo "conflict_commit="
            echo "conflict_commit_short="
            echo "conflict_subject="
            echo "custom_summary="
            echo "applied_summary="
            echo "error="
          } >> $GITHUB_OUTPUT

          if ! git rev-parse "$UPSTREAM_TAG" >/dev/null 2>&1; then
            echo "❌ Upstream tag $UPSTREAM_TAG not found"
            echo "error=upstream_tag_not_found" >> $GITHUB_OUTPUT
            exit 0
          fi

          git branch -D "$BRANCH_NAME" 2>/dev/null || true
          git checkout -b "$BRANCH_NAME" "$UPSTREAM_TAG"

          CUSTOM_COMMITS=$(git log --reverse --pretty=format:"%H" "$BASE_TAG..origin/main" 2>/dev/null || echo "")
          CUSTOM_SUMMARY=$(git log --reverse --pretty=format:"- %s (%h)" "$BASE_TAG..origin/main" 2>/dev/null || echo "")

          if [ -n "$CUSTOM_SUMMARY" ]; then
            {
              echo "custom_summary<<EOF"
              echo "$CUSTOM_SUMMARY"
              echo "EOF"
            } >> $GITHUB_OUTPUT
          fi

          if [ -z "$CUSTOM_COMMITS" ]; then
            echo "⚠️  No custom commits found between $BASE_TAG and main"
            echo "error=no_custom_commits" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Custom commits to rebase:"
          echo "$CUSTOM_COMMITS"

          CONFLICTS=false
          CONFLICT_COMMIT=""
          CONFLICT_SUBJECT=""
          for commit in $CUSTOM_COMMITS; do
            echo "Cherry-picking $commit..."
            if ! git cherry-pick "$commit"; then
              echo "❌ Conflict detected on commit $commit"
              CONFLICTS=true
              CONFLICT_COMMIT="$commit"
              CONFLICT_SUBJECT=$(git log -1 --pretty=format:"%s" "$commit")
              git cherry-pick --abort
              break
            fi
          done

          if [ "$CONFLICTS" = true ]; then
            echo "conflicts=true" >> $GITHUB_OUTPUT
            echo "error=rebase_conflict" >> $GITHUB_OUTPUT

            if [ -n "$CONFLICT_COMMIT" ]; then
              echo "conflict_commit=$CONFLICT_COMMIT" >> $GITHUB_OUTPUT
              echo "conflict_commit_short=$(git rev-parse --short "$CONFLICT_COMMIT")" >> $GITHUB_OUTPUT
              echo "conflict_subject=$CONFLICT_SUBJECT" >> $GITHUB_OUTPUT
            fi

            AHEAD_COUNT=$(git rev-list --count "${UPSTREAM_TAG}..HEAD")

            if [ "$AHEAD_COUNT" -gt 0 ]; then
              echo "Some commits were applied before the conflict. Preparing branch $BRANCH_NAME for review."
              set -e
              git push origin "$BRANCH_NAME" --force-with-lease
              echo "needs_pr=true" >> $GITHUB_OUTPUT
              echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

              APPLIED_SUMMARY=$(git log --reverse --pretty=format:"- %s (%h)" "${UPSTREAM_TAG}..HEAD")
              if [ -n "$APPLIED_SUMMARY" ]; then
                {
                  echo "applied_summary<<EOF"
                  echo "$APPLIED_SUMMARY"
                  echo "EOF"
                } >> $GITHUB_OUTPUT
              fi
            else
              echo "No commits were applied before the conflict. Creating issue for manual follow-up."
              echo "needs_issue=true" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi

          echo "✅ Rebase successful"
          echo "success=true" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          set -e
          git push origin "$BRANCH_NAME" --force-with-lease
      
      - name: 'Merge to main'
        if: steps.rebase.outputs.success == 'true'
        run: |
          BRANCH_NAME="update-to-${{ steps.check.outputs.latest }}"
          git checkout main
          git merge "$BRANCH_NAME" --ff-only
          git push origin main
          git push origin --delete "$BRANCH_NAME"
      
      - name: 'Build bundle'
        if: steps.rebase.outputs.success == 'true'
        run: |
          npm ci
          npm run bundle
      
      - name: 'Create GitHub Release'
        if: steps.rebase.outputs.success == 'true'
        run: |
          LATEST_VERSION="${{ steps.check.outputs.latest }}"
          RELEASE_TAG="v${LATEST_VERSION}-custom"
          
          # Create release with bundle
          gh release create "$RELEASE_TAG" \
            --title "v${LATEST_VERSION} (Custom Fork)" \
            --notes "Automated release based on upstream @google/gemini-cli v${LATEST_VERSION}
          
          ## Custom Changes
          - Custom keybinds and clipboard support
          - Detailed logging
          - Custom system prompts
          
          ## Installation
          \`\`\`bash
          curl -L -o ~/.local/bin/gemini https://github.com/ismellpillows/gemini-cli/releases/download/${RELEASE_TAG}/gemini.js
          chmod +x ~/.local/bin/gemini
          \`\`\`
          
          The CLI will auto-update on next run." \
            bundle/gemini.js
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 'Create PR for manual rebase'
        if: steps.rebase.outputs.needs_pr == 'true'
        run: |
          LATEST_VERSION="${{ steps.check.outputs.latest }}"
          UPSTREAM_TAG="${{ steps.check.outputs.upstream_tag }}"
          BASE_TAG="${{ steps.base.outputs.base_tag }}"
          BRANCH_NAME="${{ steps.rebase.outputs.branch_name }}"
          CONFLICT_COMMIT="${{ steps.rebase.outputs.conflict_commit }}"
          CONFLICT_COMMIT_SHORT="${{ steps.rebase.outputs.conflict_commit_short }}"
          CONFLICT_SUBJECT="${{ steps.rebase.outputs.conflict_subject }}"
          APPLIED_SUMMARY="${{ steps.rebase.outputs.applied_summary }}"
          CUSTOM_SUMMARY="${{ steps.rebase.outputs.custom_summary }}"

          CHERRY_PICK_COMMAND="${CONFLICT_COMMIT:-<commit-sha>}"
          CHERRY_PICK_TARGET="${CONFLICT_COMMIT_SHORT:-the next commit}"

          PR_BODY=$(mktemp)
          cat <<EOF > "$PR_BODY"
## Manual follow-up required

The automated rebase from **$BASE_TAG** to **$UPSTREAM_TAG** stopped at commit ${CONFLICT_COMMIT_SHORT:-n/a}${CONFLICT_SUBJECT:+: $CONFLICT_SUBJECT}.

Applied commits so far:
${APPLIED_SUMMARY:-"(none yet)"}

Remaining custom commits:
${CUSTOM_SUMMARY:-"(see git log for details)"}

### Next steps
1. Fetch this branch: \`git fetch origin $BRANCH_NAME && git checkout $BRANCH_NAME\`
2. Resume cherry-picking starting from ${CHERRY_PICK_TARGET}. Run \`git cherry-pick $CHERRY_PICK_COMMAND\`, resolve conflicts, and continue with \`git cherry-pick --continue\`.
3. Run project checks and verify the CLI.
4. Push updates: \`git push origin $BRANCH_NAME --force-with-lease\`.
EOF

          gh pr create \
            --base main \
            --head "$BRANCH_NAME" \
            --title "Update to v${LATEST_VERSION} - manual follow-up required" \
            --body-file "$PR_BODY"
          rm "$PR_BODY"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 'Create issue for manual update'
        if: steps.rebase.outputs.needs_issue == 'true'
        run: |
          LATEST_VERSION="${{ steps.check.outputs.latest }}"
          UPSTREAM_TAG="${{ steps.check.outputs.upstream_tag }}"
          BASE_TAG="${{ steps.base.outputs.base_tag }}"
          CONFLICT_COMMIT_SHORT="${{ steps.rebase.outputs.conflict_commit_short }}"
          CONFLICT_SUBJECT="${{ steps.rebase.outputs.conflict_subject }}"
          CUSTOM_SUMMARY="${{ steps.rebase.outputs.custom_summary }}"

          CHERRY_PICK_COMMAND="${{ steps.rebase.outputs.conflict_commit }}"

          if [ -z "$CHERRY_PICK_COMMAND" ]; then
            CHERRY_PICK_COMMAND="<commit-sha>"
          fi

          ISSUE_BODY=$(mktemp)
          cat <<EOF > "$ISSUE_BODY"
## Manual update to v${LATEST_VERSION} required

The automated rebase from **$BASE_TAG** to **$UPSTREAM_TAG** hit a conflict at commit ${CONFLICT_COMMIT_SHORT:-n/a}${CONFLICT_SUBJECT:+: $CONFLICT_SUBJECT} before any commits could be applied automatically.

Custom commits to carry forward:
${CUSTOM_SUMMARY:-"(review origin/main for custom commits)"}

### Suggested steps
1. Fetch upstream: \`git fetch upstream --tags\`
2. Create a working branch from the upstream tag: \`git checkout -b update-to-${LATEST_VERSION} $UPSTREAM_TAG\`
3. Cherry-pick commits from \`origin/main\` starting at ${CONFLICT_COMMIT_SHORT:-the first custom commit}. Begin with \`git cherry-pick $CHERRY_PICK_COMMAND\`.
4. Resolve conflicts, push the branch, and create a PR when ready.
EOF

          gh issue create \
            --title "Manual update to v${LATEST_VERSION} required" \
            --body-file "$ISSUE_BODY"
          rm "$ISSUE_BODY"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 'Summary'
        if: always()
        run: |
          echo "## Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Current version: ${{ steps.check.outputs.current }}" >> $GITHUB_STEP_SUMMARY
          echo "- Latest upstream: ${{ steps.check.outputs.latest }}" >> $GITHUB_STEP_SUMMARY
          echo "- Update needed: ${{ steps.check.outputs.update_needed }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.rebase.outputs.success }}" = "true" ]; then
            echo "- ✅ Rebase successful" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Release created" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.rebase.outputs.needs_pr }}" = "true" ]; then
            echo "- ⚠️  Conflicts detected - PR opened for manual follow-up" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.rebase.outputs.needs_issue }}" = "true" ]; then
            echo "- ⚠️  Conflicts detected - Issue opened for manual follow-up" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.check.outputs.update_needed }}" = "false" ]; then
            echo "- ℹ️  Already up to date" >> $GITHUB_STEP_SUMMARY
          elif [ -n "${{ steps.rebase.outputs.error }}" ]; then
            echo "- ❌ Update blocked: ${{ steps.rebase.outputs.error }}" >> $GITHUB_STEP_SUMMARY
          fi
